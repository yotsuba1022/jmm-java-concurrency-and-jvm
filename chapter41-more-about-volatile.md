# More About Volatile

### 前言

前面一篇是站在JMM的角度去詮釋volatile及其背後的運作機制的, 這邊只是要做一些簡單的補充而已, 算是把我還有想到跟讀到的一些東西補進來.

在多執行緒並發的開發情境下, synchronized和volatile都扮演著重要的角色, volatile是輕量級的synchronized, 其在多處理器開發中保證了共享變數的"可見性". 透過之前的章節, 我們可以知道可見性指的就是當一個執行緒修改一個共享變數時, 另外一個執行緒可以讀到這個被修改的值.

### Volatile的官方定義

* Java語言規範第三版中對volatile的定義如下: Java允許執行緒存取共享變數, 為了確保共享變數能被準確且一致的更新, 執行緒應該確保通過排他鎖單獨獲取這個變數. Java提供了volatile, 在某些情況下比lock更加方便. 若一個field被宣告成volatile, JMM就會確保所有執行緒看到這個變數的值是一致的.

### 為何要使用volatile

* volatile如果使用恰當的話, 相較於synchronized, 其使用和執行成本會更低, 因為其不會引起執行緒context的切換與調度.

### Volatile的實作原理

* 那麼volatile是如何來保證可見性的呢? 在x86處理器下通過工具獲取JIT編譯器生成的組合語言指令來看看volatile進行寫入操作時, CPU會做哪些事情:  
  ![](/assets/jmm-85.png)

  有volatile變數修飾的共享變數進行寫入操作時會多出第二行的組合語言代碼, 通過查詢IA-32架構軟體開發者手冊可知, lock prefix的指令在多核心處理器下會引發兩件事情:

  * 將當前處理器快取塊的資料寫回至系統記憶體

  * 這個寫回記憶體的操作會引起在其它CPU裡快取了該記憶體地址的資料無效化

* 


