# The Implementation of Atomic Operations

### 前言

原子\(atom\)的本意是"無法再被進一步分割的最小粒子", 至於原子操作\(atomic operation\)則是"**不可被中斷的一個或一系列操作**". 在多處理器上實作原子操作就變得有點複雜, 這篇要紀錄的心得是Intel處理器與Java實作原子操作的方式.

### 處理器如何實作原子操作

32-bits的IA-32處理器使用了基於對快取上鎖或對匯流排\(bus\)上鎖的方式來實作多處理器之間的原子操作

* #### 處理器自動保證基本記憶體操作的原子性

  首先, 處理器會自動保證基本的記憶體操作之原子性. 處理器保證從系統記憶體當中讀取或著寫入一個byte是原子的, 即當一個處理器讀取一個byte時, 其它處理器不能存取這個byte的記憶體位置. Pentium6和最新的處理器能自動保證單處理器對同一個cache line裡進行16/32/64 bits的操作是原子的, 但對於複雜的記憶體操作來說, 處理器不能自動保證其原子性, 譬如跨bus寬度, 跨多個cache line, 跨page table的存取. 但處理器提供bus locking以及cache locking這兩種機制來保證複雜記憶體操作的原子性.

* #### 使用bus lock保證原子性

  此機制是通過對bus上鎖保證原子性: 若多個處理器同時對共享變數進行讀改寫\(i++就是讀改寫的一種例子\)操作, 那麼共享變數就會被多個處理器同時進行操作, 這樣讀改寫操作就不是原子的了, 操作完之後共享變數的值會和期望的不一致, 譬如說, 若i = 1, 且由兩個執行序進行兩次i++操作, 這時候期望得到i = 3, 但結果卻有可能是2. 

  原因是可能有多個處理器同時從各自的cache中讀取變數i, 並分別進行+1的操作, 然後分別寫入系統記憶體內. 若想要保證讀改寫共享變數的操作是原子的, 就必須保證CPU1讀改寫變數i的時候, CPU2不能操作該變數i在記憶體地址的快取.

  處理器使用bus locking就是要解決這種問題的, 所謂的bus locking就是使用處理器提供的一個LOCK\#訊號, 當一個處理器在bus上輸出這個訊號時, 其它處理器的request就會被blocking, 然後當前這個處理器就可以獨佔地使用共享記憶體.

* #### 使用cache lock保證原子性

### Java如何實作原子操作

使用循環CAS實作原子操作

使用lock機制實作原子操作

