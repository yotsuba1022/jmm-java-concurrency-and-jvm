# GC - GC Algorithms

在JVM裡, 有很多種的Garbage Collector, 其使用的演算法以及適合的場景也大不相同, 這篇會簡單記錄一下目前常見的Garbage Collection演算法, 但不會深入談細部的演算法實作\(我功力還不到\) .

### Mark-Sweep

這應該可以說是最陽春的演算法了, 正如其名, 演算法分成以下兩階段:

* Mark: 標記出所有需要回收的物件\(標記過程在前一個chapter已經提過了\)
* Sweep: 在標記完成後統一回收所有被標記的物件

之所以說這個是最陽春的演算法, 是因為後續的演算法都是基於這裡的概念去改進其不足的部分而出現的. 其不足的部分大概有以下兩點:

* 效率問題: Mark/Sweep的效率其實並不高
* 空間問題: 在Mark/Sweep之後, 可能會產生大量不連續的記憶體碎片, 記憶體碎片太多會導致之後在程式運作的過程中需要分配較大的物件時, 無法找到足夠的連續記憶體而不得不提前觸發另一次的GC動作.

下圖就是Mark-Sweep的簡單示意圖:

### Copying

為了解決效率問題, 這個演算法出現了, 其將可用記憶體按照容量劃分為大小相等的兩塊, 每次只使用其中的一塊. 若當前使用的這塊記憶體用光了, 就把還存活的物件複製到另一塊上面, 然後再把當前已使用的記憶體空間清乾淨. 這就是說, 每次都是對整個半塊的記憶體進行回收, 所以分配時也不用管碎片問題了, 只要移動Heap指標, 按順序分配記憶體即可, 實作簡單且高效. 可是代價其實也不小, 因為記憶體縮小成原來的一半了. 下圖是Copying的簡單示意圖:

其實, 現在大多數的商用解決方案幾乎都是採用這個方式來回收新生代的, 以HotSpot為例, 大致上會把記憶體分為以下三個部分:

* Eden Area: 物件一開始生出來大概都會進到這裡, 是三塊裡面空間最大的
* From Survivor: 在某些情況下, Eden Area的物件可以晉升到這裡
* To Survivor: 這裡就是前面提到的兩塊記憶體\(這邊的兩塊就是指From Survivor/To Survivor\)的另一塊

具體的運作方式大概是這樣: 每次使用Eden和其中一塊Survivor, 當回收時, 將Eden和當前的Survivor中還活著的物件都一次性複製到另外一個Survivor區塊中, 最後清掉Eden和剛才用過的Survivor. HotSpot默認Eden和Survivor的空間大小比例為8:1, 也就是新生代中可用記憶體空間為整個新生代容量的90%\(80% + 10%\), 剩下的10%就是預備的那個Survivor. 當Survivor不夠用時, 就必須依靠其它記憶體\(通常指老年代, 即Tenured Generation\)來進行擔保\(Handle Promotion\).

### Mark-Compact

123

